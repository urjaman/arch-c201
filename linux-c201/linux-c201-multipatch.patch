diff --git a/Documentation/devicetree/bindings/clock/rockchip,rk3288-cru.txt b/Documentation/devicetree/bindings/clock/rockchip,rk3288-cru.txt
index 8cb47c39ba53..20724584e0a4 100644
--- a/Documentation/devicetree/bindings/clock/rockchip,rk3288-cru.txt
+++ b/Documentation/devicetree/bindings/clock/rockchip,rk3288-cru.txt
@@ -16,6 +16,9 @@ Optional Properties:
 
 - rockchip,grf: phandle to the syscon managing the "general register files"
   If missing pll rates are not changeable, due to the missing pll lock status.
+- rockchip,npll-for-vop: u32 0 or 1, dedicates NPLL to a VOP output unit for
+  more frequency flexibility for the selected VOP output at a cost of
+  flexibility for other devices. Disabled if not present or -1.
 
 Each clock is assigned an identifier and client nodes can use this identifier
 to specify the clock which they consume. All available clocks are defined as
diff --git a/Documentation/devicetree/bindings/display/rockchip/dw_hdmi-rockchip.txt b/Documentation/devicetree/bindings/display/rockchip/dw_hdmi-rockchip.txt
index 3d32ce137e7f..a87b2aedfceb 100644
--- a/Documentation/devicetree/bindings/display/rockchip/dw_hdmi-rockchip.txt
+++ b/Documentation/devicetree/bindings/display/rockchip/dw_hdmi-rockchip.txt
@@ -38,6 +38,7 @@ Optional properties
 - clock-names: May contain "vpll", external clock for some hdmi phy.
 - phys: from general PHY binding: the phandle for the PHY device.
 - phy-names: Should be "hdmi" if phys references an external phy.
+- rockchip,hdmi-rates-hz: List of allowed HDMI frequencies in Hz.
 
 Optional pinctrl entry:
 - If you have both a "unwedge" and "default" pinctrl entry, dw_hdmi
diff --git a/arch/arm/boot/dts/rk3288-veyron-chromebook.dtsi b/arch/arm/boot/dts/rk3288-veyron-chromebook.dtsi
index ffb60f880b39..c14770158edd 100644
--- a/arch/arm/boot/dts/rk3288-veyron-chromebook.dtsi
+++ b/arch/arm/boot/dts/rk3288-veyron-chromebook.dtsi
@@ -83,6 +83,68 @@
 	};
 };
 
+&cru {
+	/* Dedicate NPLL for VOP0 / VOP_BIG for HDMI. */
+	rockchip,npll-for-vop = <0>;
+	/* The first assigned clocks are DCLK_VOP0 and DCLK_VOP1 */
+	assigned-clock-parents = <&cru PLL_NPLL>, <&cru PLL_GPLL>;
+};
+
+/* Delete the nodes that allow non-desirable VOP - connector links. That
+ * is the eDP cannot use vopb and HDMI cannot use vopl. */
+
+/delete-node/ &edp_in_vopb;
+/delete-node/ &vopb_out_edp;
+/delete-node/ &hdmi_in_vopl;
+/delete-node/ &vopl_out_hdmi;
+
+&hdmi {
+	/* These depend on NPLL being dedicated to HDMI use. */
+	rockchip,hdmi-rates-hz = <
+		25176471	/* for 25.175 MHz, 0.006% off */
+		25200000
+		27000000
+		28320000
+		30240000
+		31500000
+		32000000
+		33750000
+		36000000
+		40000000
+		49500000
+		50000000
+		54000000
+		57290323	/* for 57.284 MHz, .011 % off */
+		65000000
+		68250000
+		71000000
+		72000000
+		73250000
+		74250000
+		74437500	/* for 74.44 MHz, .003% off */
+		75000000
+		78750000
+		78800000
+		79500000
+		83500000
+		85500000
+		88750000
+		97750000
+		101000000
+		106500000
+		108000000
+		115500000
+		118666667	/* for 118.68 MHz, .011% off */
+		119000000
+		121714286	/* for 121.75 MHz, .029% off */
+		135000000
+		136800000	/* for 136.75 MHz, .037% off */
+		146250000
+		148500000
+		154000000
+		162000000 >;
+};
+
 &rk808 {
 	vcc11-supply = <&vcc_5v>;
 
diff --git a/arch/arm/boot/dts/rk3288-veyron-edp.dtsi b/arch/arm/boot/dts/rk3288-veyron-edp.dtsi
index b12e061c5f7f..b007c09652cb 100644
--- a/arch/arm/boot/dts/rk3288-veyron-edp.dtsi
+++ b/arch/arm/boot/dts/rk3288-veyron-edp.dtsi
@@ -93,13 +93,13 @@
 		panel-timing {
 			clock-frequency = <74250000>;
 			hactive = <1366>;
-			hfront-porch = <136>;
+			hfront-porch = <87>;
 			hback-porch = <60>;
 			hsync-len = <30>;
 			hsync-active = <0>;
 			vactive = <768>;
 			vfront-porch = <8>;
-			vback-porch = <12>;
+			vback-porch = <14>;
 			vsync-len = <12>;
 			vsync-active = <0>;
 		};
diff --git a/arch/arm/boot/dts/rk3288-veyron.dtsi b/arch/arm/boot/dts/rk3288-veyron.dtsi
index 7525e3dd1fc1..bad7584b60f8 100644
--- a/arch/arm/boot/dts/rk3288-veyron.dtsi
+++ b/arch/arm/boot/dts/rk3288-veyron.dtsi
@@ -182,6 +182,7 @@
 	mmc-hs200-1_8v;
 	mmc-pwrseq = <&emmc_pwrseq>;
 	non-removable;
+	no-recovery-cache-flush;
 	pinctrl-names = "default";
 	pinctrl-0 = <&emmc_clk &emmc_cmd &emmc_bus8>;
 };
@@ -464,8 +465,8 @@
 
 	assigned-clocks = <&cru SCLK_USBPHY480M_SRC>;
 	assigned-clock-parents = <&usbphy0>;
-	dr_mode = "host";
 	snps,need-phy-for-wake;
+	/* dr_mode = "host"; */
 };
 
 &vopb {
diff --git a/arch/arm/boot/dts/rk3288.dtsi b/arch/arm/boot/dts/rk3288.dtsi
index cc893e154fe5..71caa444bc63 100644
--- a/arch/arm/boot/dts/rk3288.dtsi
+++ b/arch/arm/boot/dts/rk3288.dtsi
@@ -867,12 +867,14 @@
 		rockchip,grf = <&grf>;
 		#clock-cells = <1>;
 		#reset-cells = <1>;
-		assigned-clocks = <&cru PLL_GPLL>, <&cru PLL_CPLL>,
+		assigned-clocks = <&cru DCLK_VOP0>, <&cru DCLK_VOP1>,
+				  <&cru PLL_GPLL>, <&cru PLL_CPLL>,
 				  <&cru PLL_NPLL>, <&cru ACLK_CPU>,
 				  <&cru HCLK_CPU>, <&cru PCLK_CPU>,
 				  <&cru ACLK_PERI>, <&cru HCLK_PERI>,
 				  <&cru PCLK_PERI>;
-		assigned-clock-rates = <594000000>, <400000000>,
+		assigned-clock-rates = <0>, <0>,
+				       <594000000>, <400000000>,
 				       <500000000>, <300000000>,
 				       <150000000>, <75000000>,
 				       <300000000>, <150000000>,
diff --git a/block/partitions/efi.c b/block/partitions/efi.c
index db2fef7dfc47..84dfe166ad66 100644
--- a/block/partitions/efi.c
+++ b/block/partitions/efi.c
@@ -330,23 +330,34 @@ static gpt_header *alloc_read_gpt_header(struct parsed_partitions *state,
  * @lba: logical block address of the GPT header to test
  * @gpt: GPT header ptr, filled on return.
  * @ptes: PTEs ptr, filled on return.
+ * @ignored is filled on return with 1 if this is an IGNOREME GPT,
+ *     0 otherwise. May be NULL.
  *
  * Description: returns 1 if valid,  0 on error.
  * If valid, returns pointers to newly allocated GPT header and PTEs.
  */
 static int is_gpt_valid(struct parsed_partitions *state, u64 lba,
-			gpt_header **gpt, gpt_entry **ptes)
+			gpt_header **gpt, gpt_entry **ptes, int *ignored)
 {
 	u32 crc, origcrc;
 	u64 lastlba, pt_size;
 
+	if (ignored)
+		*ignored = 0;
 	if (!ptes)
 		return 0;
 	if (!(*gpt = alloc_read_gpt_header(state, lba)))
 		return 0;
 
 	/* Check the GUID Partition Table signature */
-	if (le64_to_cpu((*gpt)->signature) != GPT_HEADER_SIGNATURE) {
+
+	if (le64_to_cpu((*gpt)->signature) == GPT_HEADER_SIGNATURE_IGNORED) {
+		pr_debug("GUID Partition Table at LBA %llu marked IGNOREME\n",
+						(unsigned long long)lba);
+		if (ignored)
+			*ignored = 1;
+		goto fail;
+	} else if (le64_to_cpu((*gpt)->signature) != GPT_HEADER_SIGNATURE) {
 		pr_debug("GUID Partition Table Header signature is wrong:"
 			 "%lld != %lld\n",
 			 (unsigned long long)le64_to_cpu((*gpt)->signature),
@@ -583,7 +594,7 @@ compare_gpts(gpt_header *pgpt, gpt_header *agpt, u64 lastlba)
 static int find_valid_gpt(struct parsed_partitions *state, gpt_header **gpt,
 			  gpt_entry **ptes)
 {
-	int good_pgpt = 0, good_agpt = 0, good_pmbr = 0;
+	int good_pgpt = 0, good_agpt = 0, good_pmbr = 0, pgpt_ignored = 0;
 	gpt_header *pgpt = NULL, *agpt = NULL;
 	gpt_entry *pptes = NULL, *aptes = NULL;
 	legacy_mbr *legacymbr;
@@ -613,19 +624,20 @@ static int find_valid_gpt(struct parsed_partitions *state, gpt_header **gpt,
 	}
 
 	good_pgpt = is_gpt_valid(state, GPT_PRIMARY_PARTITION_TABLE_LBA,
-				 &pgpt, &pptes);
+			 &pgpt, &pptes, &pgpt_ignored);
         if (good_pgpt)
 		good_agpt = is_gpt_valid(state,
 					 le64_to_cpu(pgpt->alternate_lba),
-					 &agpt, &aptes);
-        if (!good_agpt && force_gpt)
-                good_agpt = is_gpt_valid(state, lastlba, &agpt, &aptes);
+					 &agpt, &aptes, NULL);
+	if (!good_agpt && (force_gpt || pgpt_ignored))
+		good_agpt = is_gpt_valid(state, lastlba, &agpt, &aptes, NULL);
 
         /* The obviously unsuccessful case */
         if (!good_pgpt && !good_agpt)
                 goto fail;
 
-        compare_gpts(pgpt, agpt, lastlba);
+	if (!pgpt_ignored)
+		compare_gpts(pgpt, agpt, lastlba);
 
         /* The good cases */
         if (good_pgpt) {
@@ -642,7 +654,8 @@ static int find_valid_gpt(struct parsed_partitions *state, gpt_header **gpt,
                 *ptes = aptes;
                 kfree(pgpt);
                 kfree(pptes);
-		pr_warn("Primary GPT is invalid, using alternate GPT.\n");
+	pr_warn("Primary GPT is %s, using alternate GPT.\n",
+		pgpt_ignored ? "being ignored" : "invalid");
                 return 1;
         }
 
diff --git a/block/partitions/efi.h b/block/partitions/efi.h
index 3e8576157575..260c24c54750 100644
--- a/block/partitions/efi.h
+++ b/block/partitions/efi.h
@@ -27,7 +27,8 @@
 #define GPT_MBR_PROTECTIVE  1
 #define GPT_MBR_HYBRID      2
 
-#define GPT_HEADER_SIGNATURE 0x5452415020494645ULL
+#define GPT_HEADER_SIGNATURE		0x5452415020494645ULL	/* 'EFI PART' */
+#define GPT_HEADER_SIGNATURE_IGNORED	0x454d45524f4e4749ULL	/* 'IGNOREME' */
 #define GPT_HEADER_REVISION_V1 0x00010000
 #define GPT_PRIMARY_PARTITION_TABLE_LBA 1
 
diff --git a/drivers/clk/rockchip/clk-rk3288.c b/drivers/clk/rockchip/clk-rk3288.c
index cc2a177bbdbf..88e9284b8c0f 100644
--- a/drivers/clk/rockchip/clk-rk3288.c
+++ b/drivers/clk/rockchip/clk-rk3288.c
@@ -189,10 +189,14 @@ PNAME(mux_ddrphy_p)		= { "dpll_ddr", "gpll_ddr" };
 PNAME(mux_aclk_cpu_src_p)	= { "cpll_aclk_cpu", "gpll_aclk_cpu" };
 
 PNAME(mux_pll_src_cpll_gpll_p)		= { "cpll", "gpll" };
-PNAME(mux_pll_src_npll_cpll_gpll_p)	= { "npll", "cpll", "gpll" };
-PNAME(mux_pll_src_cpll_gpll_npll_p)	= { "cpll", "gpll", "npll" };
+PNAME_ED(mux_pll_src_npll_cpll_gpll_p)	= { "npll", "cpll", "gpll" };
+
+PNAME_ED(mux_pll_src_cgn_pll_nonvop_p)	= { "cpll", "gpll", "npll" };
+PNAME_ED(mux_pll_src_cgn_pll_vop0_p) = { "cpll", "gpll", "npll" };
+PNAME_ED(mux_pll_src_cgn_pll_vop1_p) = { "cpll", "gpll", "npll" };
+
 PNAME(mux_pll_src_cpll_gpll_usb480m_p)	= { "cpll", "gpll", "unstable:usbphy480m_src" };
-PNAME(mux_pll_src_cpll_gll_usb_npll_p)	= { "cpll", "gpll", "unstable:usbphy480m_src", "npll" };
+PNAME_ED(mux_pll_src_cpll_gll_usb_npll_p) = { "cpll", "gpll", "unstable:usbphy480m_src", "npll" };
 
 PNAME(mux_mmc_src_p)	= { "cpll", "gpll", "xin24m", "xin24m" };
 PNAME(mux_i2s_pre_p)	= { "i2s_src", "i2s_frac", "ext_i2s", "xin12m" };
@@ -438,24 +442,24 @@ static struct rockchip_clk_branch rk3288_clk_branches[] __initdata = {
 			RK3288_CLKSEL_CON(30), 14, 2, MFLAGS, 8, 5, DFLAGS,
 			RK3288_CLKGATE_CON(3), 4, GFLAGS),
 
-	COMPOSITE(DCLK_VOP0, "dclk_vop0", mux_pll_src_cpll_gpll_npll_p, 0,
+	COMPOSITE(DCLK_VOP0, "dclk_vop0", mux_pll_src_cgn_pll_vop0_p, 0,
 			RK3288_CLKSEL_CON(27), 0, 2, MFLAGS, 8, 8, DFLAGS,
 			RK3288_CLKGATE_CON(3), 1, GFLAGS),
-	COMPOSITE(DCLK_VOP1, "dclk_vop1", mux_pll_src_cpll_gpll_npll_p, 0,
+	COMPOSITE(DCLK_VOP1, "dclk_vop1", mux_pll_src_cgn_pll_vop1_p, 0,
 			RK3288_CLKSEL_CON(29), 6, 2, MFLAGS, 8, 8, DFLAGS,
 			RK3288_CLKGATE_CON(3), 3, GFLAGS),
 
 	COMPOSITE_NODIV(SCLK_EDP_24M, "sclk_edp_24m", mux_edp_24m_p, 0,
 			RK3288_CLKSEL_CON(28), 15, 1, MFLAGS,
 			RK3288_CLKGATE_CON(3), 12, GFLAGS),
-	COMPOSITE(SCLK_EDP, "sclk_edp", mux_pll_src_cpll_gpll_npll_p, 0,
+	COMPOSITE(SCLK_EDP, "sclk_edp", mux_pll_src_cgn_pll_nonvop_p, 0,
 			RK3288_CLKSEL_CON(28), 6, 2, MFLAGS, 0, 6, DFLAGS,
 			RK3288_CLKGATE_CON(3), 13, GFLAGS),
 
-	COMPOSITE(SCLK_ISP, "sclk_isp", mux_pll_src_cpll_gpll_npll_p, 0,
+	COMPOSITE(SCLK_ISP, "sclk_isp", mux_pll_src_cgn_pll_nonvop_p, 0,
 			RK3288_CLKSEL_CON(6), 6, 2, MFLAGS, 0, 6, DFLAGS,
 			RK3288_CLKGATE_CON(3), 14, GFLAGS),
-	COMPOSITE(SCLK_ISP_JPE, "sclk_isp_jpe", mux_pll_src_cpll_gpll_npll_p, 0,
+	COMPOSITE(SCLK_ISP_JPE, "sclk_isp_jpe", mux_pll_src_cgn_pll_nonvop_p, 0,
 			RK3288_CLKSEL_CON(6), 14, 2, MFLAGS, 8, 6, DFLAGS,
 			RK3288_CLKGATE_CON(3), 15, GFLAGS),
 
@@ -464,16 +468,16 @@ static struct rockchip_clk_branch rk3288_clk_branches[] __initdata = {
 	GATE(SCLK_HDMI_CEC, "sclk_hdmi_cec", "xin32k", 0,
 			RK3288_CLKGATE_CON(5), 11, GFLAGS),
 
-	COMPOSITE(ACLK_HEVC, "aclk_hevc", mux_pll_src_cpll_gpll_npll_p, 0,
+	COMPOSITE(ACLK_HEVC, "aclk_hevc", mux_pll_src_cgn_pll_nonvop_p, 0,
 			RK3288_CLKSEL_CON(39), 14, 2, MFLAGS, 8, 5, DFLAGS,
 			RK3288_CLKGATE_CON(13), 13, GFLAGS),
 	DIV(HCLK_HEVC, "hclk_hevc", "aclk_hevc", 0,
 			RK3288_CLKSEL_CON(40), 12, 2, DFLAGS),
 
-	COMPOSITE(SCLK_HEVC_CABAC, "sclk_hevc_cabac", mux_pll_src_cpll_gpll_npll_p, 0,
+	COMPOSITE(SCLK_HEVC_CABAC, "sclk_hevc_cabac", mux_pll_src_cgn_pll_nonvop_p, 0,
 			RK3288_CLKSEL_CON(42), 6, 2, MFLAGS, 0, 5, DFLAGS,
 			RK3288_CLKGATE_CON(13), 14, GFLAGS),
-	COMPOSITE(SCLK_HEVC_CORE, "sclk_hevc_core", mux_pll_src_cpll_gpll_npll_p, 0,
+	COMPOSITE(SCLK_HEVC_CORE, "sclk_hevc_core", mux_pll_src_cgn_pll_nonvop_p, 0,
 			RK3288_CLKSEL_CON(42), 14, 2, MFLAGS, 8, 5, DFLAGS,
 			RK3288_CLKGATE_CON(13), 15, GFLAGS),
 
@@ -547,7 +551,7 @@ static struct rockchip_clk_branch rk3288_clk_branches[] __initdata = {
 	COMPOSITE(0, "sclk_tspout", mux_tspout_p, 0,
 			RK3288_CLKSEL_CON(35), 14, 2, MFLAGS, 8, 5, DFLAGS,
 			RK3288_CLKGATE_CON(4), 11, GFLAGS),
-	COMPOSITE(0, "sclk_tsp", mux_pll_src_cpll_gpll_npll_p, 0,
+	COMPOSITE(0, "sclk_tsp", mux_pll_src_cgn_pll_nonvop_p, 0,
 			RK3288_CLKSEL_CON(35), 6, 2, MFLAGS, 0, 5, DFLAGS,
 			RK3288_CLKGATE_CON(4), 10, GFLAGS),
 
@@ -917,6 +921,7 @@ static struct syscore_ops rk3288_clk_syscore_ops = {
 static void __init rk3288_clk_init(struct device_node *np)
 {
 	struct rockchip_clk_provider *ctx;
+	s32 npll_vop = -1;
 
 	rk3288_cru_base = of_iomap(np, 0);
 	if (!rk3288_cru_base) {
@@ -924,6 +929,46 @@ static void __init rk3288_clk_init(struct device_node *np)
 		return;
 	}
 
+	if (!of_property_read_s32(np, "rockchip,npll-for-vop", &npll_vop)) {
+		if ((npll_vop < -1) || (npll_vop > 1)) {
+			pr_warn("%s: invalid VOP to dedicate NPLL to: %d\n",
+				__func__, npll_vop);
+		} else if (npll_vop >= 0) {
+			unsigned int vop_clk_id;
+			const char ** npll_names;
+			const char ** non_npll_names;
+			int i;
+
+			/* Firstly, not-VOP needs to not use npll */
+			mux_pll_src_npll_cpll_gpll_p[0] = "dummy_npll";
+			mux_pll_src_cgn_pll_nonvop_p[2] = "dummy_npll";
+			mux_pll_src_cpll_gll_usb_npll_p[3] = "dummy_npll";
+
+			/* Then the npll VOP needs to only use npll, and the other one not use npll. */
+			if (npll_vop) {
+				vop_clk_id = DCLK_VOP1;
+				npll_names = mux_pll_src_cgn_pll_vop1_p;
+				non_npll_names = mux_pll_src_cgn_pll_vop0_p;
+			} else {
+				vop_clk_id = DCLK_VOP0;
+				npll_names = mux_pll_src_cgn_pll_vop0_p;
+				non_npll_names = mux_pll_src_cgn_pll_vop1_p;
+			}
+			npll_names[0] = "dummy_cpll";
+			npll_names[1] = "dummy_gpll";
+			non_npll_names[2] = "dummy_npll";
+
+			/* Lastly the npll-dedicated-VOP needs to be able to control npll. */
+			for (i = 0; i < ARRAY_SIZE(rk3288_clk_branches); i++) {
+				if (rk3288_clk_branches[i].id == vop_clk_id) {
+					rk3288_clk_branches[i].flags |= CLK_SET_RATE_PARENT;
+					break;
+				}
+			}
+			pr_debug("%s: npll dedicated for VOP %d\n", __func__, npll_vop);
+		}
+	}
+
 	ctx = rockchip_clk_init(np, rk3288_cru_base, CLK_NR_CLKS);
 	if (IS_ERR(ctx)) {
 		pr_err("%s: rockchip clk init failed\n", __func__);
diff --git a/drivers/clk/rockchip/clk.h b/drivers/clk/rockchip/clk.h
index 2271a84124b0..85b310df1fe0 100644
--- a/drivers/clk/rockchip/clk.h
+++ b/drivers/clk/rockchip/clk.h
@@ -386,6 +386,9 @@ struct clk *rockchip_clk_register_muxgrf(const char *name,
 
 #define PNAME(x) static const char *const x[] __initconst
 
+/* For when you want to be able to modify the pointers. */
+#define PNAME_ED(x) static const char * x[] __initdata
+
 enum rockchip_clk_branch_type {
 	branch_composite,
 	branch_mux,
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index 8abb31f83ffc..a023d85d0468 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -1726,16 +1726,25 @@ static const struct panel_desc innolux_g121x1_l03 = {
  * porch, back porch, or sync length.  For now we'll leave a single setting
  * here which allows a bit of tweaking of the pixel clock at the expense of
  * refresh rate.
+ *
+ * Experimental testing with one panel suggests that the split among
+ * front/back/sync is not important, but the panel is not stable
+ * at htotal less than 1520 (atleast when running at 74.25 Mhz).
+ *
+ * There exists an experimental mode that gives very close to 60 Hz mode
+ * from 74.25 Mhz with htotal 1543 and vtotal 802 - we allow the
+ * hfront_porch and vback_porch to be adjusted to reach that mode.
+ *
  */
 static const struct display_timing innolux_n116bge_timing = {
 	.pixelclock = { 72600000, 76420000, 80240000 },
 	.hactive = { 1366, 1366, 1366 },
-	.hfront_porch = { 136, 136, 136 },
+	.hfront_porch = { 87, 136, 136 },
 	.hback_porch = { 60, 60, 60 },
 	.hsync_len = { 30, 30, 30 },
 	.vactive = { 768, 768, 768 },
 	.vfront_porch = { 8, 8, 8 },
-	.vback_porch = { 12, 12, 12 },
+	.vback_porch = { 12, 12, 14 },
 	.vsync_len = { 12, 12, 12 },
 	.flags = DISPLAY_FLAGS_VSYNC_LOW | DISPLAY_FLAGS_HSYNC_LOW,
 };
diff --git a/drivers/gpu/drm/panfrost/panfrost_gem_shrinker.c b/drivers/gpu/drm/panfrost/panfrost_gem_shrinker.c
index 288e46c40673..bae9d580ebb5 100644
--- a/drivers/gpu/drm/panfrost/panfrost_gem_shrinker.c
+++ b/drivers/gpu/drm/panfrost/panfrost_gem_shrinker.c
@@ -78,7 +78,7 @@ panfrost_gem_shrinker_scan(struct shrinker *shrinker, struct shrink_control *sc)
 	mutex_unlock(&pfdev->shrinker_lock);
 
 	if (freed > 0)
-		pr_info_ratelimited("Purging %lu bytes\n", freed << PAGE_SHIFT);
+		dev_dbg(pfdev->dev, "Purging %lu bytes\n", freed << PAGE_SHIFT);
 
 	return freed;
 }
diff --git a/drivers/gpu/drm/panfrost/panfrost_job.c b/drivers/gpu/drm/panfrost/panfrost_job.c
index 9f770d454684..2b12aa87ff32 100644
--- a/drivers/gpu/drm/panfrost/panfrost_job.c
+++ b/drivers/gpu/drm/panfrost/panfrost_job.c
@@ -344,13 +344,13 @@ static struct dma_fence *panfrost_job_run(struct drm_sched_job *sched_job)
 	struct dma_fence *fence = NULL;
 
 	if (unlikely(job->base.s_fence->finished.error))
-		return NULL;
+		return ERR_PTR(job->base.s_fence->finished.error);
 
 	pfdev->jobs[slot] = job;
 
 	fence = panfrost_fence_create(pfdev, slot);
 	if (IS_ERR(fence))
-		return NULL;
+		return ERR_PTR(-ENOMEM);
 
 	if (job->done_fence)
 		dma_fence_put(job->done_fence);
diff --git a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
index 906891b03a38..547bf147a5cc 100644
--- a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
+++ b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
@@ -72,122 +72,141 @@ struct rockchip_hdmi {
 	struct clk *grf_clk;
 	struct dw_hdmi *hdmi;
 	struct phy *phy;
+	u32* rates;
+	u32 rates_cnt;
 };
 
+#define CLK_SLOP(clk)		((clk) / 1000)
+#define CLK_PLUS_SLOP(clk)	((clk) + CLK_SLOP(clk))
+
 #define to_rockchip_hdmi(x)	container_of(x, struct rockchip_hdmi, x)
 
+/* These were the rates allowed by the driver before rates list in device tree,
+ * so keep them around as a fallback */
+static const u32 dw_hdmi_fallback_rates[] = {
+	27000000,
+	36000000,
+	40000000,
+	54000000,
+	65000000,
+	66000000,
+	74250000,
+	83500000,
+	106500000,
+	108000000,
+	146250000,
+	148500000
+};
+
 static const struct dw_hdmi_mpll_config rockchip_mpll_cfg[] = {
 	{
-		27000000, {
-			{ 0x00b3, 0x0000},
-			{ 0x2153, 0x0000},
-			{ 0x40f3, 0x0000}
+		30666000, {
+			{ 0x00b3, 0x0000 },
+			{ 0x2153, 0x0000 },
+			{ 0x40f3, 0x0000 },
+		},
+	},  {
+		36800000, {
+			{ 0x00b3, 0x0000 },
+			{ 0x2153, 0x0000 },
+			{ 0x40a2, 0x0001 },
 		},
-	}, {
-		36000000, {
-			{ 0x00b3, 0x0000},
-			{ 0x2153, 0x0000},
-			{ 0x40f3, 0x0000}
+	},  {
+		46000000, {
+			{ 0x00b3, 0x0000 },
+			{ 0x2142, 0x0001 },
+			{ 0x40a2, 0x0001 },
 		},
-	}, {
-		40000000, {
-			{ 0x00b3, 0x0000},
-			{ 0x2153, 0x0000},
-			{ 0x40f3, 0x0000}
+	},  {
+		61333000, {
+			{ 0x0072, 0x0001 },
+			{ 0x2142, 0x0001 },
+			{ 0x40a2, 0x0001 },
 		},
-	}, {
-		54000000, {
-			{ 0x0072, 0x0001},
-			{ 0x2142, 0x0001},
-			{ 0x40a2, 0x0001},
+	},  {
+		73600000, {
+			{ 0x0072, 0x0001 },
+			{ 0x2142, 0x0001 },
+			{ 0x4061, 0x0002 },
 		},
-	}, {
-		65000000, {
-			{ 0x0072, 0x0001},
-			{ 0x2142, 0x0001},
-			{ 0x40a2, 0x0001},
+	},  {
+		92000000, {
+			{ 0x0072, 0x0001 },
+			{ 0x2145, 0x0002 },
+			{ 0x4061, 0x0002 },
 		},
-	}, {
-		66000000, {
-			{ 0x013e, 0x0003},
-			{ 0x217e, 0x0002},
-			{ 0x4061, 0x0002}
+	},  {
+		122666000, {
+			{ 0x0051, 0x0002 },
+			{ 0x2145, 0x0002 },
+			{ 0x4061, 0x0002 },
 		},
-	}, {
-		74250000, {
-			{ 0x0072, 0x0001},
-			{ 0x2145, 0x0002},
-			{ 0x4061, 0x0002}
+	},  {
+		147200000, {
+			{ 0x0051, 0x0002 },
+			{ 0x2145, 0x0002 },
+			{ 0x4064, 0x0003 },
 		},
-	}, {
-		83500000, {
-			{ 0x0072, 0x0001},
+	},  {
+		184000000, {
+			{ 0x0051, 0x0002 },
+			{ 0x214c, 0x0003 },
+			{ 0x4064, 0x0003 },
 		},
-	}, {
-		108000000, {
-			{ 0x0051, 0x0002},
-			{ 0x2145, 0x0002},
-			{ 0x4061, 0x0002}
+	},  {
+		226666000, {
+			{ 0x0040, 0x0003 },
+			{ 0x214c, 0x0003 },
+			{ 0x4064, 0x0003 },
 		},
-	}, {
-		106500000, {
-			{ 0x0051, 0x0002},
-			{ 0x2145, 0x0002},
-			{ 0x4061, 0x0002}
+	},  {
+		272000000, {
+			{ 0x0040, 0x0003 },
+			{ 0x214c, 0x0003 },
+			{ 0x5a64, 0x0003 },
 		},
-	}, {
-		146250000, {
-			{ 0x0051, 0x0002},
-			{ 0x2145, 0x0002},
-			{ 0x4061, 0x0002}
+	},  {
+		340000000, {
+			{ 0x0040, 0x0003 },
+			{ 0x3b4c, 0x0003 },
+			{ 0x5a64, 0x0003 },
 		},
-	}, {
-		148500000, {
-			{ 0x0051, 0x0003},
-			{ 0x214c, 0x0003},
-			{ 0x4064, 0x0003}
+	},  {
+		600000000, {
+			{ 0x1a40, 0x0003 },
+			{ 0x3b4c, 0x0003 },
+			{ 0x5a64, 0x0003 },
 		},
-	}, {
+	},  {
 		~0UL, {
-			{ 0x00a0, 0x000a },
-			{ 0x2001, 0x000f },
-			{ 0x4002, 0x000f },
+			{ 0x0000, 0x0000 },
+			{ 0x0000, 0x0000 },
+			{ 0x0000, 0x0000 },
 		},
 	}
 };
 
 static const struct dw_hdmi_curr_ctrl rockchip_cur_ctr[] = {
-	/*      pixelclk    bpp8    bpp10   bpp12 */
+	/*      pixelclk     bpp8    bpp10   bpp12 */
 	{
-		40000000,  { 0x0018, 0x0018, 0x0018 },
-	}, {
-		65000000,  { 0x0028, 0x0028, 0x0028 },
-	}, {
-		66000000,  { 0x0038, 0x0038, 0x0038 },
-	}, {
-		74250000,  { 0x0028, 0x0038, 0x0038 },
-	}, {
-		83500000,  { 0x0028, 0x0038, 0x0038 },
-	}, {
-		146250000, { 0x0038, 0x0038, 0x0038 },
-	}, {
-		148500000, { 0x0000, 0x0038, 0x0038 },
-	}, {
-		~0UL,      { 0x0000, 0x0000, 0x0000},
-	}
+		600000000, { 0x0000, 0x0000, 0x0000 },
+	},  {
+		~0UL,      { 0x0000, 0x0000, 0x0000 },
+	},
 };
 
 static const struct dw_hdmi_phy_config rockchip_phy_config[] = {
 	/*pixelclk   symbol   term   vlev*/
-	{ 74250000,  0x8009, 0x0004, 0x0272},
-	{ 148500000, 0x802b, 0x0004, 0x028d},
-	{ 297000000, 0x8039, 0x0005, 0x028d},
-	{ ~0UL,	     0x0000, 0x0000, 0x0000}
+	{ CLK_PLUS_SLOP(74250000),  0x8009, 0x0004, 0x0272},
+	{ CLK_PLUS_SLOP(165000000), 0x802b, 0x0004, 0x0209},
+	{ CLK_PLUS_SLOP(297000000), 0x8039, 0x0005, 0x028d},
+	{ ~0UL,	                    0x0000, 0x0000, 0x0000}
 };
 
 static int rockchip_hdmi_parse_dt(struct rockchip_hdmi *hdmi)
 {
 	struct device_node *np = hdmi->dev->of_node;
+	int rates_cnt;
 
 	hdmi->regmap = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
 	if (IS_ERR(hdmi->regmap)) {
@@ -215,26 +234,55 @@ static int rockchip_hdmi_parse_dt(struct rockchip_hdmi *hdmi)
 		return PTR_ERR(hdmi->grf_clk);
 	}
 
+	if ((rates_cnt = of_property_count_u32_elems(np, "rockchip,hdmi-rates-hz")) > 0) {
+		int rv;
+		u32 *rates = devm_kmalloc_array(hdmi->dev, rates_cnt, sizeof(u32), GFP_KERNEL);
+		if (!rates)
+			return -ENOMEM;
+		rv = of_property_read_u32_array(np, "rockchip,hdmi-rates-hz", rates, rates_cnt);
+		if (rv)
+			return rv;
+		hdmi->rates = rates;
+		hdmi->rates_cnt = rates_cnt;
+	} else {
+		rates_cnt = ARRAY_SIZE(dw_hdmi_fallback_rates);
+		hdmi->rates = devm_kmalloc_array(hdmi->dev, rates_cnt, sizeof(u32), GFP_KERNEL);
+		if (!hdmi->rates)
+			return -ENOMEM;
+		memcpy(hdmi->rates, dw_hdmi_fallback_rates, rates_cnt * sizeof(u32));
+		hdmi->rates_cnt = rates_cnt;
+	}
+
+
 	return 0;
 }
 
 static enum drm_mode_status
-dw_hdmi_rockchip_mode_valid(struct drm_connector *connector,
+dw_hdmi_rockchip_encoder_mode_valid(struct drm_encoder *encoder,
 			    const struct drm_display_mode *mode)
 {
-	const struct dw_hdmi_mpll_config *mpll_cfg = rockchip_mpll_cfg;
+	struct rockchip_hdmi *hdmi = to_rockchip_hdmi(encoder);
 	int pclk = mode->clock * 1000;
-	bool valid = false;
+	int num_rates = hdmi->rates_cnt;
 	int i;
 
-	for (i = 0; mpll_cfg[i].mpixelclock != (~0UL); i++) {
-		if (pclk == mpll_cfg[i].mpixelclock) {
-			valid = true;
-			break;
-		}
+	/*
+	 * Pixel clocks we support are always < 2GHz and so fit in an
+	 * int.  We should make sure source rate does too so we don't get
+	 * overflow when we multiply by 1000.
+	 */
+	if (mode->clock > INT_MAX / 1000)
+		return MODE_BAD;
+
+	for (i = 0; i < num_rates; i++) {
+		int slop = CLK_SLOP(pclk);
+
+		if ((pclk >= hdmi->rates[i] - slop) &&
+		    (pclk <= hdmi->rates[i] + slop))
+			return MODE_OK;
 	}
 
-	return (valid) ? MODE_OK : MODE_BAD;
+	return MODE_BAD;
 }
 
 static const struct drm_encoder_funcs dw_hdmi_rockchip_encoder_funcs = {
@@ -250,7 +298,39 @@ dw_hdmi_rockchip_encoder_mode_fixup(struct drm_encoder *encoder,
 				    const struct drm_display_mode *mode,
 				    struct drm_display_mode *adj_mode)
 {
-	return true;
+	struct rockchip_hdmi *hdmi = to_rockchip_hdmi(encoder);
+	int pclk = adj_mode->clock * 1000;
+	int best_diff = INT_MAX;
+	int best_clock = 0;
+	int slop;
+	int i;
+
+	/* Pick the best clock */
+	for (i = 0; i < hdmi->rates_cnt; i++) {
+		int diff = hdmi->rates[i] - pclk;
+
+		if (diff < 0)
+			diff = -diff;
+		if (diff < best_diff) {
+			best_diff = diff;
+			best_clock = hdmi->rates[i];
+
+			/* Bail early if we're exact */
+			if (best_diff == 0)
+				return true;
+		}
+	}
+
+	/* Double check that it's OK */
+	slop = CLK_SLOP(pclk);
+	if ((pclk >= best_clock - slop) && (pclk <= best_clock + slop)) {
+		adj_mode->clock = DIV_ROUND_UP(best_clock, 1000);
+		return true;
+	}
+
+	/* Shoudn't be here; we should have said rate wasn't valid */
+	dev_warn(hdmi->dev, "tried to set invalid rate %d\n", adj_mode->clock);
+	return false;
 }
 
 static void dw_hdmi_rockchip_encoder_mode_set(struct drm_encoder *encoder,
@@ -306,6 +386,7 @@ dw_hdmi_rockchip_encoder_atomic_check(struct drm_encoder *encoder,
 }
 
 static const struct drm_encoder_helper_funcs dw_hdmi_rockchip_encoder_helper_funcs = {
+	.mode_valid = dw_hdmi_rockchip_encoder_mode_valid,
 	.mode_fixup = dw_hdmi_rockchip_encoder_mode_fixup,
 	.mode_set   = dw_hdmi_rockchip_encoder_mode_set,
 	.enable     = dw_hdmi_rockchip_encoder_enable,
@@ -405,7 +486,6 @@ static struct rockchip_hdmi_chip_data rk3228_chip_data = {
 };
 
 static const struct dw_hdmi_plat_data rk3228_hdmi_drv_data = {
-	.mode_valid = dw_hdmi_rockchip_mode_valid,
 	.mpll_cfg = rockchip_mpll_cfg,
 	.cur_ctr = rockchip_cur_ctr,
 	.phy_config = rockchip_phy_config,
@@ -422,7 +502,6 @@ static struct rockchip_hdmi_chip_data rk3288_chip_data = {
 };
 
 static const struct dw_hdmi_plat_data rk3288_hdmi_drv_data = {
-	.mode_valid = dw_hdmi_rockchip_mode_valid,
 	.mpll_cfg   = rockchip_mpll_cfg,
 	.cur_ctr    = rockchip_cur_ctr,
 	.phy_config = rockchip_phy_config,
@@ -442,7 +521,6 @@ static struct rockchip_hdmi_chip_data rk3328_chip_data = {
 };
 
 static const struct dw_hdmi_plat_data rk3328_hdmi_drv_data = {
-	.mode_valid = dw_hdmi_rockchip_mode_valid,
 	.mpll_cfg = rockchip_mpll_cfg,
 	.cur_ctr = rockchip_cur_ctr,
 	.phy_config = rockchip_phy_config,
@@ -459,7 +537,6 @@ static struct rockchip_hdmi_chip_data rk3399_chip_data = {
 };
 
 static const struct dw_hdmi_plat_data rk3399_hdmi_drv_data = {
-	.mode_valid = dw_hdmi_rockchip_mode_valid,
 	.mpll_cfg   = rockchip_mpll_cfg,
 	.cur_ctr    = rockchip_cur_ctr,
 	.phy_config = rockchip_phy_config,
@@ -557,6 +634,7 @@ static int dw_hdmi_rockchip_bind(struct device *dev, struct device *master,
 	 */
 	if (IS_ERR(hdmi->hdmi)) {
 		ret = PTR_ERR(hdmi->hdmi);
+		devm_kfree(hdmi->dev, hdmi->rates);
 		drm_encoder_cleanup(encoder);
 		clk_disable_unprepare(hdmi->vpll_clk);
 	}
@@ -569,6 +647,7 @@ static void dw_hdmi_rockchip_unbind(struct device *dev, struct device *master,
 {
 	struct rockchip_hdmi *hdmi = dev_get_drvdata(dev);
 
+	devm_kfree(hdmi->dev, hdmi->rates);
 	dw_hdmi_unbind(hdmi->hdmi);
 	clk_disable_unprepare(hdmi->vpll_clk);
 }
diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_vop.c b/drivers/gpu/drm/rockchip/rockchip_drm_vop.c
index 84e3decb17b1..b1d84d250c8f 100644
--- a/drivers/gpu/drm/rockchip/rockchip_drm_vop.c
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_vop.c
@@ -117,7 +117,13 @@ struct vop_win {
 	struct vop *vop;
 };
 
+
+/* Only export 256 since that is what userspace uses for now. */
+#define EXT_GAMMA_LUT_SIZE 256
+#define GAMMA_LUT_SIZE 1024
+
 struct rockchip_rgb;
+
 struct vop {
 	struct drm_crtc crtc;
 	struct device *dev;
@@ -143,6 +149,12 @@ struct vop {
 	/* physical map length of vop register */
 	uint32_t len;
 
+	/* Gamma tables, not part of regs as specified in dt. */
+	uint32_t hwgamma_shadow[GAMMA_LUT_SIZE];
+	void __iomem *hwgamma;
+	unsigned long gamma_upd;
+	bool gamma_lut_active;
+
 	/* one time only one process allowed to config the register */
 	spinlock_t reg_lock;
 	/* lock vop irq reg */
@@ -1174,6 +1186,12 @@ static void vop_crtc_atomic_enable(struct drm_crtc *crtc,
 		VOP_REG_SET(vop, common, dither_down_en, 0);
 	}
 
+	/* Default to no gamma tables for now. */
+	if (vop->hwgamma) {
+		VOP_REG_SET(vop, common, dsp_lut_en, 0);
+		vop->gamma_lut_active = false;
+	}
+
 	VOP_REG_SET(vop, common, out_mode, s->output_mode);
 
 	VOP_REG_SET(vop, modeset, htotal_pw, (htotal << 16) | hsync_len);
@@ -1222,6 +1240,65 @@ static void vop_wait_for_irq_handler(struct vop *vop)
 	synchronize_irq(vop->irq);
 }
 
+static void vop_write_gamma_lut(struct vop* vop)
+{
+	uint32_t i;
+
+	for (i = 0; i < GAMMA_LUT_SIZE; i++) {
+		writel(vop->hwgamma_shadow[i], vop->hwgamma + (i * 4));
+	}
+}
+
+static void vop_gamma_vsync(struct vop* vop)
+{
+	uint32_t prev_lut_en = vop_read_reg(vop, 0, &vop->data->common->dsp_lut_en);
+	if (prev_lut_en) {
+		/* Flip the LUT off so we can update next time. */
+		VOP_REG_SET(vop, common, dsp_lut_en, 0);
+	} else {
+		vop_write_gamma_lut(vop);
+		VOP_REG_SET(vop, common, dsp_lut_en, 1);
+		WRITE_ONCE(vop->gamma_upd, 0);
+	}
+	vop_cfg_done(vop);
+}
+
+static bool vop_compute_gamma_lut(struct vop* vop)
+{
+	struct drm_crtc *crtc = &vop->crtc;
+	struct drm_color_lut *lut = crtc->state->gamma_lut->data;
+	bool changed = false;
+	uint32_t i, n;
+	const uint32_t rep = GAMMA_LUT_SIZE / EXT_GAMMA_LUT_SIZE;
+
+	for (i = 0; i < EXT_GAMMA_LUT_SIZE; i++) {
+		uint32_t val = drm_color_lut_extract(lut[i].red, 10) << 20 |
+			       drm_color_lut_extract(lut[i].green, 10) << 10 |
+			       drm_color_lut_extract(lut[i].blue, 10);
+		if (val != vop->hwgamma_shadow[i*rep]) changed = true;
+		for (n = 0; n < rep; n++) {
+			vop->hwgamma_shadow[(i * rep) + n] = val;
+		}
+	}
+	return changed;
+}
+
+static void vop_update_gamma_lut(struct vop* vop)
+{
+	struct drm_crtc *crtc = &vop->crtc;
+	if (crtc->state->gamma_lut) {
+		bool changed = vop_compute_gamma_lut(vop);
+		if ((vop->gamma_lut_active) && (!changed)) return;
+		vop->gamma_lut_active = true;
+		WRITE_ONCE(vop->gamma_upd, 1);
+	} else {
+		/* Identity/noop gamma, just disable the lut. */
+		vop->gamma_lut_active = false;
+		WRITE_ONCE(vop->gamma_upd, 0);
+		VOP_REG_SET(vop, common, dsp_lut_en, 0);
+	}
+}
+
 static void vop_crtc_atomic_flush(struct drm_crtc *crtc,
 				  struct drm_crtc_state *old_crtc_state)
 {
@@ -1236,6 +1313,9 @@ static void vop_crtc_atomic_flush(struct drm_crtc *crtc,
 
 	spin_lock(&vop->reg_lock);
 
+	if ((vop->hwgamma) && (crtc->state->color_mgmt_changed))
+		vop_update_gamma_lut(vop);
+
 	vop_cfg_done(vop);
 
 	spin_unlock(&vop->reg_lock);
@@ -1386,6 +1466,7 @@ static const struct drm_crtc_funcs vop_crtc_funcs = {
 	.page_flip = drm_atomic_helper_page_flip,
 	.destroy = vop_crtc_destroy,
 	.reset = vop_crtc_reset,
+	.gamma_set = drm_atomic_helper_legacy_gamma_set,
 	.atomic_duplicate_state = vop_crtc_duplicate_state,
 	.atomic_destroy_state = vop_crtc_destroy_state,
 	.enable_vblank = vop_crtc_enable_vblank,
@@ -1471,6 +1552,7 @@ static irqreturn_t vop_isr(int irq, void *data)
 	if (active_irqs & FS_INTR) {
 		drm_crtc_handle_vblank(crtc);
 		vop_handle_vblank(vop);
+		if (READ_ONCE(vop->gamma_upd)) vop_gamma_vsync(vop);
 		active_irqs &= ~FS_INTR;
 		ret = IRQ_HANDLED;
 	}
@@ -1549,6 +1631,9 @@ static int vop_create_crtc(struct vop *vop)
 		goto err_cleanup_planes;
 
 	drm_crtc_helper_add(crtc, &vop_crtc_helper_funcs);
+	/* Gamma tables */
+	drm_mode_crtc_set_gamma_size(crtc, EXT_GAMMA_LUT_SIZE);
+	drm_crtc_enable_color_mgmt(crtc, 0, false, EXT_GAMMA_LUT_SIZE);
 
 	/*
 	 * Create drm_planes for overlay windows with possible_crtcs restricted
@@ -1864,6 +1949,19 @@ static int vop_bind(struct device *dev, struct device *master, void *data)
 	}
 	vop->irq = (unsigned int)irq;
 
+	if (vop->data->gamma_lut_offset) {
+		const unsigned int gamma_len = GAMMA_LUT_SIZE*4;
+		resource_size_t gamma_addr = res->start + vop->data->gamma_lut_offset;
+		struct resource gamma_res = DEFINE_RES_MEM_NAMED(gamma_addr, gamma_len, "rockchip gamma LUT");
+		vop->hwgamma = devm_ioremap_resource(dev, &gamma_res);
+		if (IS_ERR(vop->hwgamma)) {
+			DRM_DEV_ERROR(dev, "failed to map gamma lut, err %ld\n", PTR_ERR(vop->hwgamma));
+			vop->hwgamma = 0;
+			goto gamma_out; /* I suppose it is better to run without gamma than fail loading. */
+		}
+	}
+gamma_out:
+
 	spin_lock_init(&vop->reg_lock);
 	spin_lock_init(&vop->irq_lock);
 	mutex_init(&vop->vop_lock);
diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_vop.h b/drivers/gpu/drm/rockchip/rockchip_drm_vop.h
index 2149a889c29d..3a4515540954 100644
--- a/drivers/gpu/drm/rockchip/rockchip_drm_vop.h
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_vop.h
@@ -71,6 +71,7 @@ struct vop_common {
 	struct vop_reg mmu_en;
 	struct vop_reg out_mode;
 	struct vop_reg standby;
+	struct vop_reg dsp_lut_en;
 };
 
 struct vop_misc {
@@ -170,7 +171,7 @@ struct vop_data {
 	const struct vop_win_yuv2yuv_data *win_yuv2yuv;
 	const struct vop_win_data *win;
 	unsigned int win_size;
-
+	unsigned int gamma_lut_offset;
 #define VOP_FEATURE_OUTPUT_RGB10	BIT(0)
 #define VOP_FEATURE_INTERNAL_RGB	BIT(1)
 	u64 feature;
diff --git a/drivers/gpu/drm/rockchip/rockchip_vop_reg.c b/drivers/gpu/drm/rockchip/rockchip_vop_reg.c
index d1494be14471..c8af95e509be 100644
--- a/drivers/gpu/drm/rockchip/rockchip_vop_reg.c
+++ b/drivers/gpu/drm/rockchip/rockchip_vop_reg.c
@@ -598,6 +598,7 @@ static const struct vop_common rk3288_common = {
 	.dither_down_en = VOP_REG(RK3288_DSP_CTRL1, 0x1, 2),
 	.pre_dither_down = VOP_REG(RK3288_DSP_CTRL1, 0x1, 1),
 	.dither_up = VOP_REG(RK3288_DSP_CTRL1, 0x1, 6),
+	.dsp_lut_en = VOP_REG(RK3288_DSP_CTRL1, 0x1, 0),
 	.data_blank = VOP_REG(RK3288_DSP_CTRL0, 0x1, 19),
 	.dsp_blank = VOP_REG(RK3288_DSP_CTRL0, 0x3, 18),
 	.out_mode = VOP_REG(RK3288_DSP_CTRL0, 0xf, 0),
@@ -646,6 +647,7 @@ static const struct vop_data rk3288_vop = {
 	.output = &rk3288_output,
 	.win = rk3288_vop_win_data,
 	.win_size = ARRAY_SIZE(rk3288_vop_win_data),
+	.gamma_lut_offset = RK3288_GAMMA_LUT_ADDR,
 };
 
 static const int rk3368_vop_intrs[] = {
@@ -816,6 +818,7 @@ static const struct vop_data rk3399_vop_big = {
 	.win = rk3368_vop_win_data,
 	.win_size = ARRAY_SIZE(rk3368_vop_win_data),
 	.win_yuv2yuv = rk3399_vop_big_win_yuv2yuv_data,
+	.gamma_lut_offset = RK3399_GAMMA_LUT_ADDR,
 };
 
 static const struct vop_win_data rk3399_vop_lit_win_data[] = {
@@ -841,6 +844,7 @@ static const struct vop_data rk3399_vop_lit = {
 	.win = rk3399_vop_lit_win_data,
 	.win_size = ARRAY_SIZE(rk3399_vop_lit_win_data),
 	.win_yuv2yuv = rk3399_vop_lit_win_yuv2yuv_data,
+	.gamma_lut_offset = RK3399_GAMMA_LUT_ADDR,
 };
 
 static const struct vop_win_data rk3228_vop_win_data[] = {
diff --git a/drivers/gpu/drm/rockchip/rockchip_vop_reg.h b/drivers/gpu/drm/rockchip/rockchip_vop_reg.h
index 6e9fa5815d4d..8142a8dcb3c8 100644
--- a/drivers/gpu/drm/rockchip/rockchip_vop_reg.h
+++ b/drivers/gpu/drm/rockchip/rockchip_vop_reg.h
@@ -113,6 +113,12 @@
 #define RK3288_DSP_VACT_ST_END			0x0194
 #define RK3288_DSP_VS_ST_END_F1			0x0198
 #define RK3288_DSP_VACT_ST_END_F1		0x019c
+/* this is the end of what the device tree includes as RK3288 registers;
+ * there is an instance of rk_iommu in between. */
+#define RK3288_WIN2_LUT_ADDR			0x0400
+#define RK3288_WIN3_LUT_ADDR			0x0800
+#define RK3288_HWC_LUT_ADDR			0x0c00
+#define RK3288_GAMMA_LUT_ADDR			0x1000
 /* register definition end */
 
 /* rk3368 register definition */
diff --git a/drivers/mmc/core/block.c b/drivers/mmc/core/block.c
index 95b41c0891d0..31db90f123fc 100644
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@ -988,12 +988,14 @@ static unsigned int mmc_blk_data_timeout_ms(struct mmc_host *host,
 static int mmc_blk_reset(struct mmc_blk_data *md, struct mmc_host *host,
 			 int type)
 {
+	int retries = 1;
 	int err;
 
 	if (md->reset_done & type)
 		return -EEXIST;
 
 	md->reset_done |= type;
+retry:
 	err = mmc_hw_reset(host);
 	/* Ensure we switch back to the correct partition */
 	if (err != -EOPNOTSUPP) {
@@ -1011,6 +1013,10 @@ static int mmc_blk_reset(struct mmc_blk_data *md, struct mmc_host *host,
 			return -ENODEV;
 		}
 	}
+	/* Retry once because the C201 eMMC can be touchy */
+	if ((err) && (retries--)) {
+		goto retry;
+	}
 	return err;
 }
 
diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index b3484def0a8b..eb6753d1c696 100644
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -316,6 +316,8 @@ int mmc_of_parse(struct mmc_host *host)
 		host->caps2 |= MMC_CAP2_NO_SD;
 	if (device_property_read_bool(dev, "no-mmc"))
 		host->caps2 |= MMC_CAP2_NO_MMC;
+	if (device_property_read_bool(dev, "no-recovery-cache-flush"))
+		host->caps2 |= MMC_CAP2_NO_RECOVERY_CACHE_FLUSH;
 
 	/* Must be after "non-removable" check */
 	if (device_property_read_u32(dev, "fixed-emmc-driver-type", &drv_type) == 0) {
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index b7159e243323..4cd052428573 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -2146,6 +2146,12 @@ static int mmc_runtime_resume(struct mmc_host *host)
 	return 0;
 }
 
+static inline int mmc_can_flush_during_recovery(
+	struct mmc_host *host)
+{
+	return (host->caps2 & MMC_CAP2_NO_RECOVERY_CACHE_FLUSH) == 0;
+}
+
 static int mmc_can_reset(struct mmc_card *card)
 {
 	u8 rst_n_function;
@@ -2160,11 +2166,14 @@ static int _mmc_hw_reset(struct mmc_host *host)
 {
 	struct mmc_card *card = host->card;
 
-	/*
-	 * In the case of recovery, we can't expect flushing the cache to work
-	 * always, but we have a go and ignore errors.
+	/* Using a "Cache flush" during recovery events seems...
+	 * "dubious" at best, and generate significant issues on
+	 * some platforms, like 10 minutes hang up, at worst.
+	 * I'm keeping this line because the old code did it but...
+	 * feel free to double check if that's needed at all.
 	 */
-	mmc_flush_cache(host->card);
+	if (mmc_can_flush_during_recovery(host))
+		mmc_flush_cache(host->card);
 
 	if ((host->caps & MMC_CAP_HW_RESET) && host->ops->hw_reset &&
 	     mmc_can_reset(card)) {
diff --git a/drivers/usb/dwc2/core.c b/drivers/usb/dwc2/core.c
index 78a4925aa118..d348238188ac 100644
--- a/drivers/usb/dwc2/core.c
+++ b/drivers/usb/dwc2/core.c
@@ -618,7 +618,7 @@ void dwc2_force_mode(struct dwc2_hsotg *hsotg, bool host)
  *
  * @hsotg: Programming view of DWC_otg controller
  */
-static void dwc2_clear_force_mode(struct dwc2_hsotg *hsotg)
+void dwc2_clear_force_mode(struct dwc2_hsotg *hsotg)
 {
 	u32 gusbcfg;
 
diff --git a/drivers/usb/dwc2/core.h b/drivers/usb/dwc2/core.h
index d08d070a0fb6..ae8e7dc2c4ee 100644
--- a/drivers/usb/dwc2/core.h
+++ b/drivers/usb/dwc2/core.h
@@ -1298,6 +1298,7 @@ int dwc2_phy_init(struct dwc2_hsotg *hsotg, bool select_phy);
 
 void dwc2_force_mode(struct dwc2_hsotg *hsotg, bool host);
 void dwc2_force_dr_mode(struct dwc2_hsotg *hsotg);
+void dwc2_clear_force_mode(struct dwc2_hsotg *hsotg);
 
 bool dwc2_is_controller_alive(struct dwc2_hsotg *hsotg);
 
diff --git a/drivers/usb/dwc2/debugfs.c b/drivers/usb/dwc2/debugfs.c
index 7f62f4cdc265..5f913cca5043 100644
--- a/drivers/usb/dwc2/debugfs.c
+++ b/drivers/usb/dwc2/debugfs.c
@@ -114,6 +114,55 @@ static const struct file_operations testmode_fops = {
 	.release	= single_release,
 };
 
+static ssize_t cur_mode_write(struct file *file, const char __user *ubuf, size_t
+		count, loff_t *ppos)
+{
+	struct seq_file		*s = file->private_data;
+	struct dwc2_hsotg	*hsotg = s->private;
+	int mode = 0;
+	char			buf[32];
+
+	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
+		return -EFAULT;
+
+	if (!strncmp(buf, "device", 6))
+		mode = 1;
+	else if (!strncmp(buf, "host", 4))
+		mode = 2;
+	else
+		mode = 0; /* otg/clear */
+
+	dwc2_clear_force_mode(hsotg);
+	switch (mode) {
+		case 1: dwc2_force_mode(hsotg, false); break;
+		case 2: dwc2_force_mode(hsotg, true); break;
+	}
+	return count;
+}
+
+
+static int cur_mode_show(struct seq_file *s, void *unused)
+{
+	struct dwc2_hsotg *hsotg = s->private;
+	seq_puts(s, dwc2_is_device_mode(hsotg) ? "device\n" : "host\n");
+	return 0;
+}
+
+
+static int cur_mode_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, cur_mode_show, inode->i_private);
+}
+
+static const struct file_operations cur_mode_fops = {
+	.owner		= THIS_MODULE,
+	.open		= cur_mode_open,
+	.write		= cur_mode_write,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
 /**
  * state_show - debugfs: show overall driver and device state.
  * @seq: The seq file to write to.
@@ -299,6 +348,7 @@ static void dwc2_hsotg_create_debug(struct dwc2_hsotg *hsotg)
 	debugfs_create_file("state", 0444, root, hsotg, &state_fops);
 	debugfs_create_file("testmode", 0644, root, hsotg, &testmode_fops);
 	debugfs_create_file("fifo", 0444, root, hsotg, &fifo_fops);
+	debugfs_create_file("cur_mode", 0644, root, hsotg, &cur_mode_fops);
 
 	/* Create one file for each out endpoint */
 	for (epidx = 0; epidx < hsotg->num_of_eps; epidx++) {
diff --git a/drivers/usb/dwc2/hcd.c b/drivers/usb/dwc2/hcd.c
index 81afe553aa66..0eea61202874 100644
--- a/drivers/usb/dwc2/hcd.c
+++ b/drivers/usb/dwc2/hcd.c
@@ -2491,7 +2491,8 @@ static void dwc2_free_dma_aligned_buffer(struct urb *urb)
 		else
 			length = urb->actual_length;
 
-		memcpy(stored_xfer_buffer, urb->transfer_buffer, length);
+		if (stored_xfer_buffer)
+			memcpy(stored_xfer_buffer, urb->transfer_buffer, length);
 	}
 	kfree(urb->transfer_buffer);
 	urb->transfer_buffer = stored_xfer_buffer;
diff --git a/drivers/usb/dwc2/hcd_intr.c b/drivers/usb/dwc2/hcd_intr.c
index a052d39b4375..128b23800036 100644
--- a/drivers/usb/dwc2/hcd_intr.c
+++ b/drivers/usb/dwc2/hcd_intr.c
@@ -1965,7 +1965,8 @@ static void dwc2_hc_chhltd_intr_dma(struct dwc2_hsotg *hsotg,
 					"hcint 0x%08x, intsts 0x%08x\n",
 					chan->hcint,
 					dwc2_readl(hsotg, GINTSTS));
-				goto error;
+				dwc2_halt_channel(hsotg, chan, qtd,
+					DWC2_HC_XFER_PERIODIC_INCOMPLETE);
 			}
 		}
 	} else {
diff --git a/drivers/usb/dwc2/hcd_queue.c b/drivers/usb/dwc2/hcd_queue.c
index 68bbac64b753..5e51ce0699e2 100644
--- a/drivers/usb/dwc2/hcd_queue.c
+++ b/drivers/usb/dwc2/hcd_queue.c
@@ -1558,6 +1558,16 @@ static void dwc2_qh_init(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,
 			device_ns += dwc_tt->usb_tt->think_time;
 		qh->device_us = NS_TO_US(device_ns);
 
+    //Only enable workaround for highspeed devices, since only low and full speed devices so split, we can just check split
+    //The packets that fail right after the firmware is transferred are on an interrupt ep so we can use that to further narrow it down
+    //The ath9k device has issues with ep 3 and ep4
+    if(!do_split && !ep_is_isoc && ep_is_int && (urb->pipe_info.ep_num == 3 || urb->pipe_info.ep_num == 4)){
+      if (urb->interval == 1){
+        urb->interval = 4;
+        dev_info(hsotg->dev, "ath9k workaround: set usb urb interval to %d\n", urb->interval);
+      }
+    }
+
 		qh->device_interval = urb->interval;
 		qh->host_interval = urb->interval * (do_split ? 8 : 1);
 
diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 3c6ce09a6db5..a0f4ed14c7cb 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -459,6 +459,8 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	 * other time after this.
 	 */
 	dwc2_force_dr_mode(hsotg);
+	/* HACK: Always start in host mode, even if you think you're an otg device :P */
+	dwc2_force_mode(hsotg, true);
 
 	retval = dwc2_init_params(hsotg);
 	if (retval)
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 4c5eb3aa8e72..25fb6b6b06c3 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -370,6 +370,7 @@ struct mmc_host {
 #define MMC_CAP2_CQE_DCMD	(1 << 24)	/* CQE can issue a direct command */
 #define MMC_CAP2_AVOID_3_3V	(1 << 25)	/* Host must negotiate down from 3.3V */
 #define MMC_CAP2_MERGE_CAPABLE	(1 << 26)	/* Host can merge a segment over the segment size */
+#define MMC_CAP2_NO_RECOVERY_CACHE_FLUSH	(1 << 27)	/* Do not flush the device cache when recovering */
 
 	int			fixed_drv_type;	/* fixed driver type for non-removable media */
 
